# 保留本地寻路的四显示信号机深度集成规划

## 一、设计原则

### 1.1 核心原则
1. **保持现有架构**：不抽离`SignalStateDisplayBlockEntity`中的寻路逻辑
2. **增强而非重构**：在现有基础上增加全局数据支持和事件集成
3. **渐进式改进**：分阶段实施，确保向后兼容
4. **性能优化**：在保持本地逻辑的前提下优化重复计算

### 1.2 技术目标
1. **解决区块依赖**：信号状态更新不依赖区块加载
2. **减少重复计算**：相同轨道段的寻路结果共享
3. **实时响应**：集成Create事件系统，快速响应列车位置变化
4. **内存优化**：共享占用状态数据，减少重复存储
5. **完善状态处理**：支持完整的四显示信号状态（红灯/黄灯/绿黄灯/绿灯/无效），确保无效状态正确处理和恢复

## 二、架构设计

### 2.1 混合架构：全局数据 + 本地逻辑

```
┌─────────────────────────────────────────────┐
│           全局信号状态管理器                 │
│        SignalStateManager (SavedData)        │
│  - 存储每个信号机完整状态（四个信号组ID等）  │
│  - 监听列车位置变化事件，更新占用状态        │
│  - 管理信号组到信号机的映射关系             │
│  - 提供全局缓存和状态恢复服务               │
└─────────────────────────────────────────────┘
                    │ 提供占用状态
                    ▼
┌─────────────────────────────────────────────┐
│          本地方块实体层（保持现有）           │
│    SignalStateDisplayBlockEntity            │
│  - 本地寻路逻辑（findForwardSignalGroups）   │
│  - 从全局管理器获取占用状态                 │
│  - 本地状态计算和红石输出                   │
│  - 用户配置界面                             │
└─────────────────────────────────────────────┘
                    │ 上传本地配置
                    ▼
┌─────────────────────────────────────────────┐
│          寻路结果缓存服务                    │
│    PathfindingCacheService                  │
│  - 缓存相同轨道段的寻路结果                 │
│  - 提供寻路结果复用                         │
│  - 管理缓存过期和清理                       │
└─────────────────────────────────────────────┘
```

### 2.2 关键组件职责

#### **全局信号状态管理器**
- 存储所有信号组的实时占用状态
- 监听Create铁路事件（列车移动、轨道变化）
- 维护信号组到信号机的反向索引
- 提供线程安全的占用状态查询

#### **本地方块实体（修改版）**
- **保持**：`findForwardSignalGroups`寻路逻辑
- **新增**：从全局管理器获取占用状态，而非本地检测
- **优化**：使用缓存服务复用寻路结果
- **增强**：事件驱动的状态更新

#### **寻路缓存服务**
- 缓存键：`轨道图ID + 起点边界ID + 进路编号`
- 缓存值：寻路结果（信号组列表、边界ID列表）
- 缓存策略：LRU + 时间过期
- 共享机制：相同轨道起点的信号机共享结果

## 三、数据流设计

### 3.1 列车位置更新流程
```
列车在轨道上移动（区块可能未加载）
    ↓
Create.RAILWAYS触发TrainPositionEvent
    ↓
全局管理器监听事件，更新信号组占用状态
    ↓
查找受影响的信号机（通过反向索引）
    ↓
如信号机区块已加载，立即通知更新
    ↓
如区块未加载，标记状态为"待更新"
    ↓
区块加载时，信号机从全局管理器同步最新状态
```

### 3.2 信号机状态计算流程
```
信号机tick()执行（区块已加载）
    ↓
检查是否需要重新寻路（边界变化/定时触发）
    ↓
向缓存服务请求寻路结果
    ├─ 缓存命中 → 获取缓存的信号组列表
    ↓
缓存未命中 → 执行本地findForwardSignalGroups
    ↓
从全局管理器获取这些信号组的占用状态
    ↓
计算四显示信号状态（红灯/黄灯/绿黄灯/绿灯/无效）
    ↓
更新红石输出和本地显示
    ↓
将寻路结果提交到缓存服务（供其他信号机使用）
```

### 3.3 红石信号处理流程
```
红石信号变化（区块可能未加载）
    ↓
全局管理器记录信号映射变化
    ↓
计算受影响信号机的进路选择
    ↓
如区块已加载，立即应用进路变化
    ↓
如区块未加载，状态保存到全局管理器
    ↓
区块加载时，信号机同步最新进路配置
```

### 3.4 区块加载/卸载状态同步流程
```
区块即将卸载
    ↓
方块实体onUnload()/setRemoved()被调用
    ↓
同步四个信号组ID、占用状态、配置等到全局管理器
    ↓
全局管理器将状态持久化到SavedData
    ↓
区块完全卸载，方块实体从内存移除
    ↓
（时间流逝...）
    ↓
区块重新加载
    ↓
方块实体onLoad()被调用
    ↓
从全局管理器读取四个信号组ID、占用状态、配置等
    ↓
恢复本地状态，标记需要重新寻路（数据可能已过期）
    ↓
正常执行tick()更新
```

## 四、关键技术实现

### 4.1 全局信号状态管理器（增强版）

现有`SignalStateManager`已实现完整的信号状态全局管理，需要进一步增强以支持区块卸载时的状态恢复：

```java
public class SignalStateManager extends SavedData {
    // 所有信号显示器的状态缓存（维度 -> 位置 -> 状态）
    private final Map<ResourceLocation, Map<BlockPos, SignalStateCache>> dimensionCache = new ConcurrentHashMap<>();

    // 信号状态缓存（核心数据结构）
    public static class SignalStateCache {
        public final BlockPos position;
        public final ResourceLocation dimension;

        // 四个信号组ID（0:当前, 1-3:前方）
        public final UUID[] signalGroupIds = new UUID[4];

        // 占用状态数组（对应信号组ID）
        public final boolean[] occupancyStates = new boolean[4];

        // 四显示信号状态（红灯/黄灯/绿黄灯/绿灯/无效）
        public SignalStateDisplayBlockEntity.FourAspectSignalState fourAspectState;

        // 配置状态
        public int currentRoute = 1;
        public boolean forceRed = false;
        public int lastRedstoneSignal = 0;

        // 连接状态
        public boolean isConnectedToTrack = false;
        public UUID connectedBoundaryId = null;
        public UUID connectedGraphId = null;

        // 寻路相关数据
        public final double[] travelDistances = new double[3];
        public final int[] travelCallCounts = new int[3];
        public long lastPathfindingTick = 0;
        public boolean needsPathfindingUpdate = true;

        // 更新时间戳
        public long lastUpdatedTick = 0;
        public long lastConfigUpdateTick = 0;
        public long lastOccupancyUpdateTick = 0;

        /**
         * 从方块实体同步完整配置
         * 在区块卸载前调用，确保全局管理器拥有最新状态
         */
        public void syncFromBlockEntity(SignalStateDisplayBlockEntity blockEntity) {
            System.arraycopy(blockEntity.getSignalGroupIds(), 0, signalGroupIds, 0, 4);
            System.arraycopy(blockEntity.getOccupancyStates(), 0, occupancyStates, 0, 4);
            this.currentRoute = blockEntity.getCurrentRoute();
            this.forceRed = blockEntity.isForceRed();
            this.lastRedstoneSignal = blockEntity.getLastRedstoneSignal();
            this.fourAspectState = blockEntity.getFourAspectState();
        }

        /**
         * 计算四显示信号状态（不依赖区块加载）
         */
        public void calculateFourAspectState() {
            if (!isConnectedToTrack || signalGroupIds[0] == null) {
                fourAspectState = SignalStateDisplayBlockEntity.FourAspectSignalState.INVALID;
                return;
            }

            if (forceRed) {
                fourAspectState = SignalStateDisplayBlockEntity.FourAspectSignalState.RED;
                return;
            }

            // 正常四显示信号计算逻辑
            if (occupancyStates[0]) {
                fourAspectState = SignalStateDisplayBlockEntity.FourAspectSignalState.RED;
            } else if (signalGroupIds[1] != null && occupancyStates[1]) {
                fourAspectState = SignalStateDisplayBlockEntity.FourAspectSignalState.YELLOW;
            } else if (signalGroupIds[2] != null && occupancyStates[2]) {
                fourAspectState = SignalStateDisplayBlockEntity.FourAspectSignalState.GREEN_YELLOW;
            } else {
                fourAspectState = SignalStateDisplayBlockEntity.FourAspectSignalState.GREEN;
            }
        }

        /**
         * 转换为NBT（用于区块卸载时持久化保存）
         */
        public CompoundTag toNBT() {
            CompoundTag tag = new CompoundTag();
            tag.putLong("pos", position.asLong());

            // 保存四个信号组ID
            for (int i = 0; i < 4; i++) {
                if (signalGroupIds[i] != null) {
                    tag.putUUID("groupId" + i, signalGroupIds[i]);
                }
            }

            // 保存占用状态
            for (int i = 0; i < 4; i++) {
                tag.putBoolean("occupied" + i, occupancyStates[i]);
            }

            // 保存其他状态
            tag.putString("fourAspectState", fourAspectState.name());
            tag.putInt("currentRoute", currentRoute);
            tag.putBoolean("forceRed", forceRed);
            tag.putInt("lastRedstoneSignal", lastRedstoneSignal);

            return tag;
        }
    }

    /**
     * 定期更新所有信号状态（不依赖区块加载）
     */
    public void tick(ServerLevel level) {
        // 1. 更新所有信号状态（占用状态和计算）
        updateAllSignalStates(level);

        // 2. 执行后台寻路服务（需要寻路的信号机）
        performPathfindingService(level, currentTick);

        // 3. 同步连接状态（检查信号机是否仍然连接到轨道）
        syncConnectionStates(level);
    }

    /**
     * 获取信号缓存（区块未加载时使用）
     */
    @Nullable
    public SignalStateCache getSignalCache(ServerLevel level, BlockPos pos) {
        ResourceLocation dimension = level.dimension().location();
        Map<BlockPos, SignalStateCache> cacheMap = dimensionCache.get(dimension);
        return cacheMap != null ? cacheMap.get(pos) : null;
    }
}
```

### 4.2 本地方块实体增强（与全局管理器集成）

四显示信号机方块实体需要与全局状态管理器深度集成，确保区块加载/卸载时的状态一致性：

```java
public class SignalStateDisplayBlockEntity extends SignalBlockEntity {
    // 四显示信号状态枚举（包含无效状态）
    public enum FourAspectSignalState {
        RED("红色"),      // 停车
        YELLOW("黄色"),   // 减速
        GREEN_YELLOW("绿黄"), // 注意通行
        GREEN("绿色"),    // 通行
        INVALID("无效");  // 信号无效或未连接

        // ... 枚举实现
    }

    // 全局管理器引用
    private SignalStateManager signalStateManager;

    /**
     * 方块实体加载时：从全局管理器恢复状态
     */
    @Override
    public void onLoad() {
        super.onLoad();

        if (!level.isClientSide && level instanceof ServerLevel serverLevel) {
            // 获取全局管理器
            signalStateManager = SignalStateManager.get(serverLevel);
            if (signalStateManager != null) {
                // 尝试从全局缓存恢复状态
                SignalStateManager.SignalStateCache cache =
                    signalStateManager.getSignalCache(serverLevel, worldPosition);
                if (cache != null) {
                    // 恢复四个信号组ID
                    System.arraycopy(cache.signalGroupIds, 0, signalGroupIds, 0, 4);

                    // 恢复占用状态
                    System.arraycopy(cache.occupancyStates, 0, occupancyStates, 0, 4);

                    // 恢复配置状态
                    currentRoute = cache.currentRoute;
                    forceRed = cache.forceRed;
                    lastRedstoneSignal = cache.lastRedstoneSignal;

                    // 标记需要重新寻路（因为可能已过期）
                    lastCheckedBoundary = null;
                }
            }
        }
    }

    /**
     * 方块实体卸载前：同步状态到全局管理器
     */
    @Override
    public void setRemoved() {
        if (!level.isClientSide && signalStateManager != null && level instanceof ServerLevel serverLevel) {
            // 创建或获取缓存对象
            SignalStateManager.SignalStateCache cache =
                signalStateManager.getSignalCache(serverLevel, worldPosition);
            if (cache == null) {
                // 创建新缓存
                cache = new SignalStateManager.SignalStateCache(
                    worldPosition, level.dimension().location()
                );
                signalStateManager.registerSignalCache(serverLevel, cache);
            }

            // 同步当前状态到缓存
            cache.syncFromBlockEntity(this);

            // 更新连接状态
            cache.syncConnectionState();

            // 标记数据已更改
            signalStateManager.setDirty();
        }

        super.setRemoved();
    }

    /**
     * 每tick更新：定期与全局管理器同步
     */
    @Override
    public void tick() {
        super.tick();
        if (level.isClientSide) return;

        // 1. 更新红石信号和进路选择
        updateRedstoneSignal();

        // 2. 获取当前信号边界（如果未连接则进入INVALID状态）
        SignalBoundary currentBoundary = getSignal();
        if (currentBoundary == null) {
            enterState(SignalBlockEntity.SignalState.INVALID);
            resetDetectionData();
            lastCheckedBoundary = null;
            return;
        }

        // 3. 条件性执行寻路
        if (shouldPerformPathfinding()) {
            findForwardSignalGroups(currentBoundary);
        }

        // 4. 更新占用状态（从全局管理器获取）
        updateOccupancyStatesFromGlobal();

        // 5. 计算四显示信号状态
        fourAspectState = calculateFourAspectSignal();

        // 6. 定期同步到全局管理器（每10秒）
        if (level.getGameTime() % 200 == 0) {
            syncToGlobalManager();
        }
    }

    /**
     * 从全局管理器获取占用状态
     */
    private void updateOccupancyStatesFromGlobal() {
        if (signalStateManager != null && level instanceof ServerLevel serverLevel) {
            SignalStateManager.SignalStateCache cache =
                signalStateManager.getSignalCache(serverLevel, worldPosition);
            if (cache != null) {
                // 使用全局管理器计算的占用状态
                System.arraycopy(cache.occupancyStates, 0, occupancyStates, 0, 4);
                return;
            }
        }

        // 备用：本地计算占用状态
        updateOccupancyStatesLocally();
    }

    /**
     * 同步当前状态到全局管理器
     */
    private void syncToGlobalManager() {
        if (signalStateManager != null && level instanceof ServerLevel serverLevel) {
            SignalStateManager.SignalStateCache cache =
                signalStateManager.getSignalCache(serverLevel, worldPosition);
            if (cache != null) {
                cache.syncFromBlockEntity(this);
                signalStateManager.setDirty();
            }
        }
    }
}
```
```

### 4.3 寻路缓存服务
```java
public class PathfindingCacheService {
    // 多级缓存结构
    private Cache<String, CachedPathfindingResult> memoryCache;
    private DiskCache diskCache; // 可选：持久化缓存

    // 缓存键构建
    private String buildCacheKey(UUID graphId, UUID boundaryId, int route) {
        return graphId + ":" + boundaryId + ":" + route;
    }

    // 智能缓存策略
    private class SmartCachePolicy {
        // 基于访问频率的权重
        // 基于轨道复杂度的优先级
        // 基于信号机数量的共享价值
    }

    // 定期清理
    private void scheduleCleanup() {
        // 清理过期缓存
        // 压缩低频缓存
        // 统计缓存命中率
    }
}
```

### 4.4 事件系统集成
```java
public class SignalSystemEventIntegration {
    // 注册Create事件监听
    public static void registerEventHandlers() {
        MinecraftForge.EVENT_BUS.register(new TrainEventHandler());
        MinecraftForge.EVENT_BUS.register(new TrackGraphEventHandler());
        MinecraftForge.EVENT_BUS.register(new SignalBoundaryEventHandler());
    }

    // 列车事件处理
    public static class TrainEventHandler {
        @SubscribeEvent(priority = EventPriority.HIGH)
        public void onTrainMoved(TrainEvent.Moved event) {
            // 更新全局占用状态
            // 实际实现中需要通过ServerLevel获取SignalStateManager实例
            // SignalStateManager manager = SignalStateManager.get(serverLevel);
            // if (manager != null) manager.updateFromTrainMovement(event.getTrain());
        }
    }

    // 自定义事件：信号机区块加载
    @SubscribeEvent
    public void onSignalChunkLoaded(SignalChunkLoadEvent event) {
        // 区块加载时，同步全局状态到本地
        syncGlobalStateToLocal(event.getBlockPos());
    }
}
```

## 五、API设计

### 5.1 设计目标
1. **简洁实用**：提供直接的信号状态查询接口，从缓存数据或方块实体实时获取状态
2. **不依赖区块**：支持区块未加载时从全局管理器获取最新状态
3. **高性能**：利用全局缓存，避免重复计算
4. **状态完整**：支持四显示信号机的所有状态（红灯/黄灯/绿黄灯/绿灯/无效）

### 5.2 实际API使用

现有的`SignalSystemAPI`类提供了直接的四显示信号状态查询，无需类型转换，直接从缓存数据或方块实体提取状态：

```java
import com.easttown.createsignalsystem.api.SignalSystemAPI;
import com.easttown.createsignalsystem.block.entity.SignalStateDisplayBlockEntity;

// 从方块位置获取四显示信号状态（支持区块未加载）
// 优先从缓存获取，区块已加载时从方块实体获取实时状态
SignalStateDisplayBlockEntity.FourAspectSignalState state =
    SignalSystemAPI.getFourAspectSignalState(level, blockPos);

// 状态判断示例
if (state == SignalStateDisplayBlockEntity.FourAspectSignalState.RED) {
    // 红灯：停车
    System.out.println("信号灯为红色，列车应停止");
} else if (state == SignalStateDisplayBlockEntity.FourAspectSignalState.GREEN_YELLOW) {
    // 绿黄灯：注意通行
    System.out.println("信号灯为绿黄色，注意前方区间占用");
} else if (state == SignalStateDisplayBlockEntity.FourAspectSignalState.INVALID) {
    // 无效：信号未连接或配置错误
    System.out.println("信号灯无效，检查轨道连接和配置");
}

// 获取其他信息（均支持区块未加载）
int currentRoute = SignalSystemAPI.getCurrentRoute(level, blockPos);      // 当前进路编号
boolean forceRed = SignalSystemAPI.isForceRed(level, blockPos);           // 是否强制红灯
UUID[] signalGroupIds = SignalSystemAPI.getSignalGroupIds(level, blockPos); // 四个信号组ID
boolean[] occupancyStates = SignalSystemAPI.getOccupancyStates(level, blockPos); // 占用状态

// 检查信号有效性
boolean isValid = SignalSystemAPI.isValidSignal(level, blockPos);
boolean isConnected = SignalSystemAPI.isConnectedToTrack(level, blockPos);

// 获取基础信号状态（转换为Create原版信号状态）
com.simibubi.create.content.trains.signal.SignalBlockEntity.SignalState baseState =
    SignalSystemAPI.getBaseSignalState(level, blockPos);
```

#### 设计原则：
1. **直接提取**：从缓存（区块未加载）或方块实体（区块已加载）直接获取数据，不做额外的类型转换
2. **类型明确**：返回具体的`FourAspectSignalState`枚举，包含四显示信号机的完整状态（红/黄/绿黄/绿/无效）
3. **无适配器**：不提供统一的信号类型适配，调用方需知道查询的是四显示信号机
4. **性能优先**：优先使用全局缓存，区块未加载时仍可获取最新状态，避免重复计算
5. **状态完整**：提供完整的信号机信息，包括四个信号组ID、占用状态、进路配置等

## 五、实施步骤

### 阶段1：基础全局支持（1周）
1. **创建全局状态管理器**
   - 实现`SavedData`子类
   - 添加信号组占用状态存储
   - 实现基本的事件监听框架

2. **修改方块实体基础**
   - 添加全局管理器引用获取
   - 修改占用状态获取逻辑（从全局获取）
   - 保持寻路逻辑不变

3. **实现基础事件监听**
   - 监听列车位置变化
   - 更新全局占用状态
   - 简单的信号机通知机制

### 阶段2：缓存和优化（1周）
1. **实现寻路缓存服务**
   - 基础内存缓存
   - 缓存键设计和命中检测
   - 简单的过期策略

2. **增强方块实体寻路**
   - 添加缓存查询逻辑
   - 结果缓存提交
   - 缓存失效检测

3. **性能监控**
   - 缓存命中率统计
   - 寻路性能监控
   - 内存使用监控

### 阶段3：高级集成（1周）
1. **完善事件系统**
   - 更多Create事件集成
   - 自定义信号系统事件
   - 跨维度事件支持

2. **红石信号全局处理**
   - 不依赖区块的红石状态跟踪
   - 进路配置的全局同步
   - 强制红灯的全局管理

3. **诊断和调试**
   - 详细的状态日志
   - 性能分析工具
   - 配置导出/导入

### 阶段4：稳定和优化（1周）
1. **性能调优**
   - 缓存策略优化
   - 事件处理优化
   - 内存使用优化

2. **稳定性增强**
   - 错误处理和恢复
   - 数据一致性保证
   - 长时间运行测试

3. **用户体验**
   - 响应速度优化
   - 配置界面增强
   - 文档更新

## 六、文件修改清单

### 6.1 新增文件
1. `src/main/java/com/easttown/createsignalsystem/system/SignalStateManager.java`
   - 全局信号状态管理（增强：记录每个信号机的四个信号组ID等完整状态）
   - SavedData持久化实现（支持区块卸载时状态保存）
   - 定期更新和状态恢复服务

2. `src/main/java/com/easttown/createsignalsystem/cache/PathfindingCacheService.java`
   - 寻路结果缓存
   - 缓存策略管理
   - 性能统计

3. `src/main/java/com/easttown/createsignalsystem/event/SignalEventHandlers.java`
   - Create事件集成
   - 自定义事件定义
   - 事件处理器注册

### 6.2 修改文件
1. `src/main/java/com/easttown/createsignalsystem/block/entity/SignalStateDisplayBlockEntity.java`
   - **保持**：`findForwardSignalGroups`方法完整逻辑
   - **修改**：占用状态从全局管理器获取
   - **新增**：缓存查询和提交逻辑
   - **增强**：事件驱动的状态更新

2. `src/main/java/com/easttown/createsignalsystem/CreateSignalSystemMod.java`
   - 注册全局管理器
   - 初始化缓存服务
   - 注册事件处理器

3. `src/main/java/com/easttown/createsignalsystem/network/NetworkHandler.java`
   - 添加全局状态同步包
   - 优化本地-全局通信
   - 添加缓存同步支持

### 6.3 配置文件
1. `src/main/resources/create_signal_system.toml`
   - 添加全局管理器配置
   - 缓存策略配置
   - 性能监控配置

## 七、兼容性保障

### 7.1 数据兼容性
1. **现有存档升级**
   - 自动初始化全局管理器
   - 迁移现有信号机状态
   - 保持NBT数据结构兼容

2. **配置兼容**
   - 现有配置自动转换
   - 用户设置保持不变
   - GUI界面无变化

### 7.2 API兼容性
1. **公共API不变**
   - 对外接口保持稳定
   - 内部重构不影响外部调用
   - 逐步弃用计划

2. **网络协议兼容**
   - 现有数据包格式不变
   - 新增数据包向后兼容
   - 版本协商机制

### 7.3 行为兼容性
1. **功能一致性**
   - 所有现有功能正常工作
   - 性能提升但不改变行为
   - Bug修复保持原有逻辑

2. **用户体验一致**
   - 操作方式不变
   - 响应时间改善
   - 稳定性增强

## 八、性能优化策略

### 8.1 缓存优化
1. **智能缓存键设计**
   - 包含轨道图、边界、进路信息
   - 考虑信号机配置差异
   - 支持部分匹配

2. **多级缓存策略**
   - L1：高频热点缓存（内存）
   - L2：低频数据缓存（可序列化）
   - 动态调整缓存大小

3. **预加载机制**
   - 基于列车移动方向预加载
   - 基于信号机密度优化
   - 基于访问模式预测

### 8.2 计算优化
1. **寻路算法优化**
   - 保持原有算法，优化内部实现
   - 减少不必要的对象创建
   - 优化循环和条件判断

2. **批量处理**
   - 多个信号机状态批量更新
   - 事件批量处理
   - 缓存批量操作

3. **异步处理**
   - 非关键操作异步化
   - 后台缓存清理
   - 延迟状态更新

### 8.3 内存优化
1. **数据结构优化**
   - 使用更高效的集合类型
   - 对象池复用
   - 压缩存储格式

2. **共享数据**
   - 寻路结果共享
   - 占用状态共享
   - 配置数据共享

3. **及时清理**
   - 无用缓存清理
   - 过期数据清理
   - 内存泄漏检测

## 九、测试策略

### 9.1 单元测试
- 全局管理器状态更新测试
- 缓存服务功能测试
- 事件处理器逻辑测试
- 数据一致性测试

### 9.2 集成测试
- 与Create铁路系统集成测试
- 区块加载/卸载场景测试
- 多信号机协同测试
- 长时间运行稳定性测试

### 9.3 性能测试
- 缓存命中率测试
- 内存使用监控
- 响应时间测试
- 高负载压力测试

### 9.4 兼容性测试
- 旧版存档升级测试
- 不同Create版本兼容测试
- 其他模组兼容测试
- 配置迁移测试

## 十、风险评估

### 10.1 技术风险
1. **事件处理延迟**
   - 风险：全局事件处理导致延迟
   - 应对：异步处理、事件合并、优先级队列

2. **缓存一致性问题**
   - 风险：缓存与真实状态不一致
   - 应对：定期验证、事件失效、版本控制

3. **内存增长**
   - 风险：全局数据导致内存占用增加
   - 应对：智能清理、数据压缩、监控告警

### 10.2 兼容性风险
1. **旧版兼容问题**
   - 风险：现有存档升级失败
   - 应对：数据迁移工具、回滚机制、详细日志

2. **事件冲突**
   - 风险：与Create事件系统冲突
   - 应对：事件优先级调整、冲突检测、兼容模式

### 10.3 开发风险
1. **复杂度控制**
   - 风险：混合架构增加复杂度
   - 应对：清晰接口设计、模块化、详细文档

2. **时间预估**
   - 风险：开发时间超出预期
   - 应对：分阶段实施、核心优先、灵活调整

## 十一、预期成果

### 11.1 技术成果
1. 区块不依赖的信号状态系统
2. 高效的寻路结果缓存机制
3. 深度集成的Create事件系统
4. 保持本地寻路逻辑的优化架构

### 11.2 用户体验
1. 更稳定的信号系统（不依赖区块）
2. 更快的响应速度（缓存优化）
3. 更低的内存占用（数据共享）
4. 更好的大规模支持

### 11.3 开发成果
1. 清晰的可维护架构
2. 完善的测试覆盖
3. 详细的集成文档
4. 可扩展的事件系统

---

**文档版本**: 1.0
**创建日期**: 2026-01-30
**最后更新**: 2026-01-30
**设计原则**: 保持本地寻路逻辑，增强全局支持